package pcg

import (
	"bytes"
	"encoding/gob"
	bls12381 "github.com/kilic/bls12-381"
)

// GeneratedTuples holds the shares of the pre-computed BBS+ signatures generated by the Eval function of the PCG.
type GeneratedTuples struct {
	Sk     *bls12381.Fr
	Tuples []*BBSPlusTuple
}

// BBSPlusTuple is a share of a pre-computed BBS+ signature generated by the Eval function of the PCG.
type BBSPlusTuple struct {
	SkShare    *bls12381.Fr
	AShare     *bls12381.Fr
	EShare     *bls12381.Fr
	SShare     *bls12381.Fr
	AlphaShare *bls12381.Fr
	DeltaShare *bls12381.Fr
}

// EmptyTuple returns an empty BBSPlusTuple.
// The amount of AeTerms, SeTerms and AskTerms is determined by s.
func NewBBSPlusTuple(SkShare, AShare, EShare, SShare, AlphaShare, DeltaShare *bls12381.Fr) *BBSPlusTuple {
	tuple := &BBSPlusTuple{
		SkShare:    bls12381.NewFr(),
		AShare:     bls12381.NewFr(),
		EShare:     bls12381.NewFr(),
		SShare:     bls12381.NewFr(),
		AlphaShare: bls12381.NewFr(),
		DeltaShare: bls12381.NewFr(),
	}
	// Copy the values of the parameters into the tuple
	tuple.SkShare.FromBytes(SkShare.ToBytes())
	tuple.AShare.FromBytes(AShare.ToBytes())
	tuple.EShare.FromBytes(EShare.ToBytes())
	tuple.SShare.FromBytes(SShare.ToBytes())
	tuple.AlphaShare.FromBytes(AlphaShare.ToBytes())
	tuple.DeltaShare.FromBytes(DeltaShare.ToBytes())
	return tuple
}

// Serialize converts a BBSPlusTuple into a byte slice.
func (t *BBSPlusTuple) Serialize() ([]byte, error) {
	var b bytes.Buffer
	encoder := gob.NewEncoder(&b)

	// serialize each field of BBSPlusTuple
	if err := encoder.Encode(t.SkShare.ToBytes()); err != nil {
		return nil, err
	}

	if err := encoder.Encode(t.AShare.ToBytes()); err != nil {
		return nil, err
	}

	if err := encoder.Encode(t.EShare.ToBytes()); err != nil {
		return nil, err
	}

	if err := encoder.Encode(t.SShare.ToBytes()); err != nil {
		return nil, err
	}

	return b.Bytes(), nil
}

// Deserialize converts a byte slice into a BBSPlusTuple.
func (t *BBSPlusTuple) Deserialize(data []byte) error {
	b := bytes.NewBuffer(data)
	decoder := gob.NewDecoder(b)

	// Deserialize SkShare, AShare, EShare, SShare
	var skShareBytes, aShareBytes, eShareBytes, sShareBytes []byte
	if err := decoder.Decode(&skShareBytes); err != nil {
		return err
	}
	t.SkShare.FromBytes(skShareBytes)

	if err := decoder.Decode(&aShareBytes); err != nil {
		return err
	}
	t.AShare.FromBytes(aShareBytes)

	if err := decoder.Decode(&eShareBytes); err != nil {
		return err
	}
	t.EShare.FromBytes(eShareBytes)

	if err := decoder.Decode(&sShareBytes); err != nil {
		return err
	}
	t.SShare.FromBytes(sShareBytes)

	return nil
}
